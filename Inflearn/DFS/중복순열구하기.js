// 1부터 N까지 번호가 적힌 구슬이 있습니다. 이 중 중복을 허락하여 M번을 뽑아 일렬로 나열
// 하는 방법을 모두 출력합니다.

// ▣ 입력설명
// 첫 번째 줄에 자연수 N(3<=N<=10)과 M(2<=M<=N) 이 주어집니다.

// ▣ 출력설명
// 첫 번째 줄에 결과를 출력합니다. 맨 마지막 총 경우의 수를 출력합니다.
// 출력순서는 사전순으로 오름차순으로 출력합니다.

// ▣ 입력예제 1
// 32

// ▣ 출력예제 1
// 11
// 12
// 13
// 21
// 22
// 23
// 31
// 32
// 33
// 9

// 중복 순열 문제는 아래와 같이 이중for문을 사용하여 해결할 수 있습니다.
// 그러나 주어지는 숫자가 3,2가 아니라 4,3이 되어도 3개를 뽑지않고 2개만 뽑는 것을 알 수 있습니다.
// 그렇다면 이 경우에는 3중 for문으로 코드를 수정해주어야합니다.
// 따라서 이 코드는 매우 비효율적인 코드라 할 수 있습니다. 유동적으로 변경되는 m의 숫자에따라
// 우리의 코드도 알맞게 결괏값을 출력해야 하는데 m이증가하면 m이증가하는 만큼 m중 for문을 도는 이러한 코드는 좋지못합니다.
// 따라서 이를 해결하기위해 재귀함수를 활용하여 문제를 해결합니다.
// 결론적으로 재귀와 반복문의 가장 큰차이는 유동적으로 변하는 값에 대응할 수 있는 방법의 차이라고 볼 수 있습니다.
function badSolution(n, m) {
  let answer = [];
  for (let i = 0; i < n; i++) {
    for (let j = 1; j <= n; j++) {
      console.log(i, j);
    }
  }
  return answer;
}

function solution(n, m) {
  let answer = [];
  let tmp = Array.from({ length: m }, () => 0);
  function dfs(v) {
    if (v === m) {
      answer.push(tmp.slice());
    } else {
      for (let i = 1; i <= n; i++) {
        tmp[v] = i;
        dfs(v + 1);
      }
    }
  }

  dfs(0);

  return answer;
}

console.log(solution(3, 2));
