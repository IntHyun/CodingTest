// 다음과 같이 여러 단위의 동전들이 주어져 있을때 거스름돈을 가장 적은 수의 동전으로 교환
// 해주려면 어떻게 주면 되는가? 각 단위의 동전은 무한정 쓸 수 있다.

// ▣ 입력설명
// 첫 번째 줄에는 동전의 종류개수 N(1<=N<=12)이 주어진다. 두 번째 줄에는 N개의 동전의 종
// 류가 주어지고, 그 다음줄에 거슬러 줄 금액 M(1<=M<=500)이 주어진다.
// 각 동전의 종류는 100원을 넘지 않는다.

// ▣ 출력설명
// 첫 번째 줄에 거슬러 줄 동전의 최소개수를 출력한다.

// ▣ 입력예제 1
// 3
// 125
// 15

// ▣ 출력예제 1
// 3

// 1원이 15개 사용되면 dfs는 그만큼 호출이 됩니다.
// 즉 15lv 까지 깊어지게 되며 시간복잡도의 성능이 매우 안좋아지게됩니다.
// 또한 이미 answer의 갚이 10이라고 정해졌다면 굳이 10보다 큰 값을 탐색할 필요가 없기때문에
// 즉, 값이 이미 3lv정도에 완성이 되었다면 더이상 아래로 뻗을 필요가 없으므로
// 아래의 코드를 좀 더 효율적으로 쓸데없는 탐색을 하지 않을 수 있게 바꿔보도록 하겠습니다.
function solution(m, arr) {
  let answer = Number.MAX_SAFE_INTEGER;
  let n = arr.length;

  function dfs(v, sum) {
    if (sum > m) return;
    // 이를 위해 아래와 같이 v의 숫자가 기존에 들어있떤 answer보다 크게되면 더이상 아래로 뻗지않게됩니다.
    // 또한 answer가 이전에 뽑힌 답과 같을때 또한 탐색을 할 필요가없기때문에 가지치기를 해주도록합니다.
    // 이렇게 가지치기 방법을 통해 불필요한 연산을 최소화 할 수 있습니다.
    if (v >= answer) return;
    if (sum === m) {
      console.log(v, sum);
      answer = Math.min(answer, v);
    } else {
      for (let i = 0; i < n; i++) {
        // for문을 사용함은 n만큼 가지를 뻗는다는 것과 같습니다. 즉  n이 3이라면 0,0이 호출되었을때
        // 가지가 아래로 3개가 뻗어나갈것을 의미합니다.
        // 반복문 안에서 함수가 호출되더라도 똑같이 작동합니다.
        // 즉 함수가 호출되면 그 순간 스택 프레임이 생성되며 같은 과정을 거치게 됩니다.
        // 따라서 순차적으로 함수를 호출하고 bye를 찍는 것이 아닌 hi를 하고 함수가 호출되면 재귀적으로 작동하다가
        // 함수가 반환된 그 시점부터 bye를 찍어줍니다. (반복문 안이라고 다를거없이 똑같음.)
        // console.log("hi")
        dfs(v + 1, sum + arr[i]);
        // console.log("bye")
      }
    }
  }

  dfs(0, 0);

  return answer;
}

let arr = [1, 2, 5];
console.log(solution(15, arr));
