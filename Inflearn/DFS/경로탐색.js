// 방향그래프가 주어지면 1번 정점에서 N번 정점으로 가는 모든 경로의 가지 수를 출력하는 프
// 로그램을 작성하세요. 아래 그래프에서 1번 정점에서 5번 정점으로 가는 가지 수는
// 12345
// 125
// 13425
// 1345
// 1425
// 145
// 총 6 가지입니다.

// ▣ 입력설명
// 첫째 줄에는 정점의 수 N(1<=N<=20)와 간선의 수 M가 주어진다. 그 다음부터 M줄에 걸쳐 연
// 결정보가 주어진다.

// ▣ 출력설명
// 총 가지수를 출력한다.

// ▣ 입력예제 1
// 59
// 12
// 13
// 14
// 21
// 23
// 25
// 34
// 42
// 45

// ▣ 출력예제 1
// 6

function solution(n, arr) {
  let answer = 0;
  // 아래와 같이 2차원 그래프를 만들어줍니다.
  let graph = Array.from(Array(n + 1), () => Array(n + 1).fill(0));
  // 그리고 특정 노드를 탐색을 했다면 탐색을 한 것을 알 수 있게 ch 배열을 만들어
  // 탐색을 했다면 0을 1로 바꾸어줍니다.
  let ch = Array.from({ length: n + 1 }, () => 0);
  let path = [];

  // 아래와 같이 for of 문을 사용하면 첫번째는 1 2 가 들어오게 됩니다 평소처럼 사용하게되면
  // [1, 2] 와 같이 들어오게됩니다.
  for (const [a, b] of arr) {
    // 아래와 같이 1을 삽입해주면 arr에 있는 각 원소들의 위치를 1을 삽입하여 표현할 수 있습니다.
    // 여기서 무방향 그래프라면 반대의 경우에도 1을 넣어주도록 합니다.
    graph[a][b] = 1;
    console.log(graph);
  }

  function dfs(v) {
    if (v === n) {
      answer++;
      console.log(path);
    } else {
      for (let i = 1; i <= n; i++) {
        // 여기서 우리가 확인해주어야 할 것은 v라는 정점에서 i라는 정점으로 갈 수 있느냐를 확인하는 것입니다.
        // 예를들어 1의 정점에서 3의정점으로 갈 수 있는지와 같은 것을 확인합니다.
        if (graph[v][i] === 1 && ch[i] === 0) {
          ch[i] = 1;
          path.push(i);
          dfs(i);
          ch[i] = 0;
          path.pop();
        }
      }
    }
  }
  // ch의 1번째 원소를 1로 설정해주지 않으면 1을 체크하지 않습니다
  // 따라서 아래와 같이 ch[1] 은 무조건 방문했다고 가정하는 것입니다.
  // 왜냐면 1에서 출발하니까
  path.push(1);
  ch[1] = 1;
  dfs(1);
  return answer;
}

let arr = [
  [1, 2],
  [1, 3],
  [1, 4],
  [2, 1],
  [2, 3],
  [2, 5],
  [3, 4],
  [4, 2],
  [4, 5],
];
console.log(solution(5, arr));
