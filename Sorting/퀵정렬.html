<!DOCTYPE html>
<html lang="ko">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>
  <script>
    // 퀵정렬은 최악의 경우 O(n ** 2)가 나오고 최선의 경우 O(nlog2n)이 나옵니다. 즉, 퀵정렬도 상황에따라선 빠른 알고리즘이 될 수 있습니다.
    // 또한 퀵정렬은 다른 정렬들과 다르게 피봇값을 사용합니다. 피봇값을 정한뒤 해당 피봇값보다 작으면 앞으로 크면 뒤로 정렬하는 식으로 정렬합니다.
    // 주로 피봇값으로 가장 많이 사용하는 것으로는 배열의 첫번째, 마지막, 중간값을 주로 사용하며 최악의경우를 피하기위해
    // 피봇값을 랜덤하게 주는 경우도 있긴합니다. 또한 피봇값을 듀얼로 주는 경우도 있긴합니다.
    // 이번시간에 저희는 피봇값을 첫번째 값으로 설정하고 정렬을 해보도록 하겠습니다.
    let 입력값 = [66, 77, 54, 32, 10, 5, 11, 15]

    // 피봇값: 66
    // [54, 32, 10, 5, 11, 15] + [66] + [77]

    // 피봇값: 54
    // [32, 10, 5, 11, 15] + [54] + [66] + [77]

    // 피봇값: 32
    // [10, 5, 11, 15] + [32] + [54] + [66] + [77]

    // 피봇값: 10
    // [5] + [10] + [11, 15] + [35] + [54] + [66] + [77]

    // 피봇값: 11

    // [5] + [10] + [11] [15] + [35] + [54] + [66] + [77]

    function 퀵정렬(입력배열) {
      let 입력배열의길이 = 입력배열.length

      if (입력배열의길이 <= 1) {
        return 입력배열
      }

      let 피벗값 = [입력배열.shift()]
      let 그룹하나 = []
      let 그룹둘 = []

      for (let i in 입력배열) {
        if (입력배열[i] < 피벗값) {
          그룹하나.push(입력배열[i])
        } else {
          그룹둘.push(입력배열[i])
        }
      }

      return 퀵정렬(그룹하나).concat(피벗값, 퀵정렬(그룹둘))
    }

    console.log(퀵정렬(입력값))
  </script>
</body>

</html>